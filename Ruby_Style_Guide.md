## 命名规则
**首字母用于区分标识符的作用域：**

**大写开头表示类或module，`@`表示对象属性，`@@`表示类属性，全大写表示常量（但可赋值），其他表示局部变量或参数；方法名也使用小写开头；使用`$`表示全局属性**

1. 小写英文或`_`开头，后跟字母数字或下划线；区分大小写
2. 避免使用关键字命名
3. 变量、属性、方法、参数名单词之间使用`_`分割的小写蛇底式命名，且不要分割字母与数字；
4. 常量使用全大写蛇底式命名
5. 类与module使用大驼峰命名
6. 以`_`开头的标识符表示未使用，可用于避免RuboCop检查警告
7. 目录、文件名使用小写蛇底式命名；一个`class`或`module`一个文件，文件名使用类或模块名
8. setter函数用`=`结尾；getter方法为常规方法；返回布尔值的使用`?`结尾，二不是以`is`/`has`开头；以`!`结尾的方法表示具有潜在风险

> *Ruby 程序代码起初是用7位ACSII 码来表示，通过语言扩展来支持EUC, SJIS 或UTF-8 等8位编码系统。Ruby 2.0 版本支持16位的Unicode 编码*

## 注释
1. 不使用中文......只让人用英文
2. 及时更新、及时更新、及时更新
3. 多文字注释，句首字母大写，还要写标点符号
4. 觉得烂就重构；尽量抽出小组件
5. 注解：

> TODO  待完善  
> FIXME 待修复  
> OPTIMIZE 表示代码有问题，低效等有可能引发性能问题  
> HACK  应该被重构  
> REVIEW  表示对代码实现提出质疑，可能并没有真正实现需要的功能

## Base

1. UTF-8编码；
2. 两个空格缩排；`case`与`when`缩排在一级
3. 操作符前后使用空格，例如`+`／`-`/`*`/；`,`之后使用空格；单行代码块的`{}`与语句使用空格，而HASH不使用空格分隔
4. 方法之间使用空行分隔；相似功能的代码块（段落）组织在一起，并使用空行与其他代码分隔；
5. 一行一条语句，不使用`;`而使用`\n`换行作为语句结束符；代码块不使用`{}`包裹；
6. 没有实体的类或方法，使用单行定义；避免定义空方法（重写父方法）
7. 链式调用尽量写在一行；避免在代码块后使用链式调用
8. 方法调用的最后一个参数后不使用`,`；多个参数使用多行写法时第一个参数与`(`、最后一个参数与`)`保持在一行
9. 优先使用简写操作符：`+=`/`-=`/`||=`...
10. 不要将赋值语句写在条件语句的条件中

```ruby
# 单行注释单独写一行，不能与相关代码块通过空行分隔，且不使用中文；避免使用多行注释
class Foo
  # 属性修饰符代码块与其他代码块（方法）使用空行分隔
  attr_reader: :foo
  
  # 方法有参数时使用 ()，具备默认值的可选参数、可变参数放在末尾
  def method(arg, arg2 = nil, arg3 = [], arg4 = nil, *arg5)
    # 操作符之间使用空格
    c = a + b
    
    [1, 2, 3].each { |n| puts n }
    
    # HASH的 { 后、} 后的空格可以有
    hash = {a: 1, b: 2}
    
    # ruby语句有返回值；方法默认隐式返回最后一条语句
    # 注意if else 缩排；case 与 when缩排在一级
    result = if a < 10
               'lt 10'
             elsif a > 10
               'gt 10'
             else
               '10'
             end
    
    # 避免显式返回，除非流程中的return
    # 对象属性都是protect的，外部只能通过getter/setter函数访问
    @bar = 3
  end
  
  # getter
  def bar
    # 没有其他代码实现主体的getter/setter应该使用属性修饰符
    @bar
  end
  
  # setter
  def bar=(value)
    @bar = value
  end
end

# 使用字面量定义数组
arr = [3, 4, 5]
# 字符串数组使用%w[]，而不是%w()
arr = %w[first two 3td]

f = foo.new

# 方法调用应该使用()，除非无参方法、DSL方法（Rake/Rails/RSpec）、具有Symbol参数的方法
# 可变参数的方法调用时可省略()，hash传递给可变参数方法时，可省略{}
f.method(3,
         4,
         5,
         6,
         7,
         8,
         9)
         
# 源文件末尾预留空行

```

## Syntax
1. 不使用`for`，而使用迭代器；`for`是由`each`实现的，且`for`无独立作用域
2. 避免使用`then`/`do`等关键字
3. 单行主体的`if`/`unless`/`while`/`until`，条件语句置尾；单条件的`if`/`unless`可使用`&&`与`||`运算代替；使用`loop`语句做无限循环而不是`while true`
4. 单条件的`if else end`使用三目运算符，但绝不嵌套`? :`表达式，避免使用多行语句三目运算；避免将`if`/`unless`语句置于代码块之后；`unless else end`（否定）转为`if else end`（肯定语句）
5. 不使用`and`/`not`/`or`，避免`!!`运算
6. `nil`是对象
7. 单行主体的代码块使用`{...}`，多行主体的代码块使用`do |arg| ... end`；绝不在`do ... end`后使用链式调用
8. 避免使用关键字作为方法、变量名；避免使用`self`，除非调用使用关键字定义的方法或调用重载方法
9. 不使用`===`，使用`==`，避免使用`eql?`代替`==`
10. 不使用嵌套方法；内部函数与外部方法处于同一作用域，且会在外部方法每次调用时重新定义
11. 使用范围操作符`100..200`代替` x >= 100 && x <= 200`，且范围操作符两边无空格
12. `x / 2 == 0`使用`x.even?`；`x / 2 == 1`使用`x.odd?`；`x == nil`使用`x.nil?`；`x == 0`使用`x.zero?`

## 其他
1. 注意拆分文件，保持小而精悍；拆分方法 5 —— 10行最佳
2. 只有类方法时，定义为模块（类方法使用`self`定义）
3. 避免使用类属性。类属性在继承链中共享，只保存一份，是真正的重载；而实例属性或方法只是重写
4. 尽量使用可见级别（`public`/`protected`/`private`）
5. Ruby使用词法作用域（静态作用域）—— 定义时确定，而不是运行时
6. `self`指代当前`class`或`module`
7. 避免使用全局变量或方法

## 字面量
```ruby
# Array
arr = ['a', 'b', 'c']
arr = %w(a b c)
# 优先使用；空格作为成员分隔符
arr = %w[a b c]
# 符号成员
arr = [:name, :age, :sex]
arr = %i[name age sex]

arr.first
arr[1]
arr.last == arr.[-1]

# Hash 对象
# 优先使用Symbold作为Hash键
# a为符号属性；b为字符串属性；混写时不能写为{a:1, 'b' => 2}
hash = {:a => 1, 'b' => 2}

# 全部为Symbol属性时
{:a => 1, :b => 2}
# 应该写为
{a: 1, b: 2}

hash[:a]
hash['b']
```

## tips
```ruby
# 调用params对象的name属性，:name为属性name的Symbol符号引用
# params为Hash对象？
params[:name]

# a ||= b 不完全等于 a = a || b；而是
# 如果a已定义，a = a || b，否则a = b
a = (a = a || b) || a = b

# lambda => 匿名函数表达式
func = ->(arg, arg1) do
         puts arg + arg1
       end
       
# 嵌套方法使用lambda
def foo(x)
  lambda
  bar = ->(arg) { ... }
  bar.call(x)
end
```